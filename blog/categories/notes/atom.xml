<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Notes | Keep Learning]]></title>
  <link href="http://xiongbupt.github.com/blog/categories/notes/atom.xml" rel="self"/>
  <link href="http://xiongbupt.github.com/"/>
  <updated>2012-06-08T22:04:22+08:00</updated>
  <id>http://xiongbupt.github.com/</id>
  <author>
    <name><![CDATA[Xiongbupt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Octopress添加标签]]></title>
    <link href="http://xiongbupt.github.com/blog/2012/06/07/octopress-add-tag/"/>
    <updated>2012-06-07T00:00:00+08:00</updated>
    <id>http://xiongbupt.github.com/blog/2012/06/07/octopress-add-tag</id>
    <content type="html"><![CDATA[<h2>前因</h2>

<p>由于之前参考中文的搜索，结果都不理想，推翻重来，直接使用<a href="http://www.google.com/">google</a>使用<code>octopress tag</code>关键词搜索到的<a href="http://aijazansari.com/2012/01/07/tag-clouds-with-octopress/">第一个返回结果</a>来修改，下面记录如下。</p>

<h3>显示所有的便签列表</h3>

<p>修改<code>source/_layouts/post.html</code>文件，使它们include一个名字为<code>tags.html</code>的新文件。</p>

<!--more-->


<p>创建一个新文件<code>source/_includes/post/tags.html</code>，整个文件的内容如下所示：<br/>
{% codeblock  source/_includes/post/tags.html lang:html %}</p>

<div id="tag_list">
    Tags:
    <ul id="tags_ul">
{% for t in page.tags  %}
        <li><a href="http://xiongbupt.github.com/tags/{{t}}/">{{t}}</a></li>
{% endfor %}
    </ul>
</div>


<p>{% endcodeblock %}</p>

<p>在<code>sass/custom/_styles.css</code>文件中添加如下内容：</p>

<p>{% codeblock sass/custom/_styles.css lang:css %}
div#tag_list {</p>

<pre><code>font-size: 12pt;
</code></pre>

<p>}</p>

<h1>tags_ul {</h1>

<pre><code>display: inline;
</code></pre>

<p>}</p>

<h1>tags_ul li:last-child:after {</h1>

<p>  content: "";
}</p>

<h1>tags_ul li:after {</h1>

<p>  content: ", ";
}</p>

<h1>tags_ul li {</h1>

<pre><code>display: inline;
</code></pre>

<p>}
{% endcodeblock %}</p>

<h3>创建tag文件和tag云</h3>

<p>使用作者提供的perl脚本文件，由于作者使用<code>Octopress</code>生成的文件是直接在public文件夹下面的，但是默认的<code>Octopress</code>生成的博客内容是在<code>/public/blog</code>文件夹下面的，因此作者的提供的perl文件需要进行一个小的改动，若没有改动将无法生成对应的tags，检查是否成功的办法是查看成功的生成了<code>source/_includes/custom/tag_cloud.html</code>文件，该文件的内容类似于下面的方式：</p>

<p>{% codeblock source/_includes/custom/tag_cloud.html  lang:html %}</p>

<div id='tag_cloud'>
<a href="http://xiongbupt.github.com/blog/tags/6LoWPAN/" title="1 entry" class="tag_1">6LoWPAN</a>
<a href="http://xiongbupt.github.com/blog/tags/Arch/" title="1 entry" class="tag_1">Arch</a>
<a href="http://xiongbupt.github.com/blog/tags/AWK/" title="1 entry" class="tag_1">AWK</a>
</div>


<p>{% endcodeblock %}
文章末尾附上修改后的<code>tagify.pl</code>文件。
在添加了该代码之后，整个生成tag的操作便是下面的步骤
{% codeblock 生成tags操作 lang:bash %}
rake generate
./tagify.pl
rake generate
{% endcodeblock %}
上面的代码只是需要在每次有新的tag加入的时候需要执行，如果新添加的博客文章没有使用新的tag，则不需要执行这个步骤，只需要按照正常的操作即可。<br/>
上面的操作一共干了三件事：</p>

<ul>
<li>生成<code>source/_includes/custom/tag_cloud.html</code>文件，文件内容如上所述。</li>
<li>对于每个tag标签，在对应的目录下生成一个<code>index.markdown</code>文件，如对于<code>Linux</code>这个标签，将会创建<code>source/tags/Linux/index.markdown</code>这样一个文件。</li>
<li>同时创建了一个<code>source/tags/index.markdown</code>的文件，可以在主页面被引用。</li>
</ul>


<h3>显示tag云标签</h3>

<p>为了在右侧显示云标签，需要修改<code>_config.yaml</code>文件，将<code>tag_cloud.html</code>文件添加到<code>default_asides</code>中，目前的博客内容没有显示该分类，若想添加云标签显示可以通过修改<code>_config.yml</code>通过添加该侧边栏完成该功能。<br/>
创建<code>source/_includes/asides/tag_cloud.html</code>文件，该文件包含了<code>soure/_includes/custom/tag_cloud.html</code>文件（该文件是由<code>tagify.pl</code>脚本文件生成的），文件的内容如下所示：
{% include_code source/_includes/asides/tag_cloud.html lang:html html/tag_cloud.html %}</p>

<p>接下来修改<code>sass/custom/_styles.css</code>文件，添加标签的<code>css</code>示例，该文件内容如下所示：</p>

<p>{% codeblock sass/custom/_styles.css lang:css %}
.tag_1 {</p>

<pre><code>font-weight: 200;
font-size: 10pt;
</code></pre>

<p>}
.tag_2 {</p>

<pre><code>font-weight: 200;
font-size: 12pt;
</code></pre>

<p>}
...
.tag_10 {</p>

<pre><code>font-weight: 900;
font-size: 24pt;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>最后在导航控制文件<code>source/_includes/custom/navigation.html</code>中增加<code>Tags</code>标签，具体修改文件如下所示：</p>

<p>{% codeblock source/_includes/custom/navigation.html lang:html %}
<li><a href="http://xiongbupt.github.com/">Home</a></li>
<li><a href="http://xiongbupt.github.com/blog/archives">Archives</a></li>
+<li><a href="http://xiongbupt.github.com/tags/">Tags</a></li>
<li><a href="http://xiongbupt.github.com/about/">About Me</a></li>
{% endcodeblock %}</p>

<h2>总结</h2>

<p>完成上述操作之后，便可以在主页的首部出现一个<code>Tags</code>的导航键，同时可以添加<code>Tags</code>分类标签到页面右侧的侧边栏，目前Tags标签功能似乎不支持中文页面的分类，待测试。</p>

<h3>代码附录</h3>

<p>{% include_code 修改后的tagify.pl lang:perl perl/tagify.pl %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VIM用户手册27笔记]]></title>
    <link href="http://xiongbupt.github.com/blog/2012/06/06/vim_help_read/"/>
    <updated>2012-06-06T00:00:00+08:00</updated>
    <id>http://xiongbupt.github.com/blog/2012/06/06/vim_help_read</id>
    <content type="html"><![CDATA[<p>VIM的查找命令与模式，这章节和正则表达式相关，可以重点查阅下。</p>

<h2>大小写忽略</h2>

<p>ignorecase  忽视大小写<br/>
smartcase   若只有小写，可匹配大小写；若含有大写，则严格匹配  <br/>
特定模式中的大小写可以使用\C来严格匹配，\c可以用来通用匹配，不区分大小写</p>

<h2>无折返查找</h2>

<p><code>:set nowrapscan</code>简单的说就是在查找到文件结束处后不再返回文件开始处重新查找。</p>

<!--more-->


<h2>查找偏移</h2>

<p><code>/pattern/2</code>，这个查找将会在单词pattern的后两行。</p>

<ul>
<li>匹配一个可选项，使用<code>\=</code>，比如

<blockquote><p>/folders\=</p></blockquote></li>
</ul>


<p>匹配的是"folder"和"folders"</p>

<ul>
<li>指定重复次数时，使用<code>\{n,m}</code>这样的形式。匹配n到m次，包括n和m，相当于一个闭区间。</li>
<li>匹配尽可能少的字符使用'{-n,m}`。与上面的作用类似，区别在于尽可能少的匹配。</li>
</ul>


<h2>多选一</h2>

<p>或的运算符是<code>\|</code>。</p>

<h2>字符范围</h2>

<table>
<thead>
<tr>
<th></th>
<th align="left">项    </th>
<th align="left">匹配         </th>
<th align="center">相当于 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left">\d </td>
<td align="left">数位         </td>
<td align="center">[0-9]</td>
</tr>
<tr>
<td></td>
<td align="left">\D </td>
<td align="left">非数位          </td>
<td align="center">[<code>^</code>0-9]</td>
</tr>
<tr>
<td></td>
<td align="left">\x </td>
<td align="left">十六进制数位 </td>
<td align="center">[0-9a-fA-F]</td>
</tr>
<tr>
<td></td>
<td align="left">\X </td>
<td align="left">非十六进制数位  </td>
<td align="center">[<code>^</code>0-9a-fA-F]</td>
</tr>
<tr>
<td></td>
<td align="left">\s </td>
<td align="left">空白字符       </td>
<td align="center">[  ]     (<code>&lt;Tab&gt;</code> 和 <code>&lt;Space&gt;</code>)</td>
</tr>
<tr>
<td></td>
<td align="left">\S </td>
<td align="left">非空白字符        </td>
<td align="center">[<code>^</code>  ]     (非 <code>&lt;Tab&gt;</code> 和 <code>&lt;Space&gt;</code>)</td>
</tr>
<tr>
<td></td>
<td align="left">\l </td>
<td align="left">小写字母       </td>
<td align="center">[a-z]</td>
</tr>
<tr>
<td></td>
<td align="left">\L </td>
<td align="left">非小写字母        </td>
<td align="center">[<code>^</code>a-z]</td>
</tr>
<tr>
<td></td>
<td align="left">\u </td>
<td align="left">大写字母       </td>
<td align="center">[A-Z]</td>
</tr>
<tr>
<td></td>
<td align="left">\U </td>
<td align="left">非大写字母        </td>
<td align="center">[<code>^</code>A-Z]</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[汇编语言学习]]></title>
    <link href="http://xiongbupt.github.com/blog/2012/06/06/assemble_language_learn/"/>
    <updated>2012-06-06T00:00:00+08:00</updated>
    <id>http://xiongbupt.github.com/blog/2012/06/06/assemble_language_learn</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VIM正则表达式学习]]></title>
    <link href="http://xiongbupt.github.com/blog/2012/06/05/vim_regex_learning/"/>
    <updated>2012-06-05T00:00:00+08:00</updated>
    <id>http://xiongbupt.github.com/blog/2012/06/05/vim_regex_learning</id>
    <content type="html"><![CDATA[<h2>VIM正则表达式</h2>

<p>之前粗略的看了正则表达式的一些内容，但是在VIM中一直用的很少，刚才无意间看到了使用VIM对词进行大小写转换，中间出现了一些正则表达式的内容，从网上找了些内容，觉得可以留下来做个笔记，供以后自己参考。<br/>
文章的主要内容参考<a href="http://qianjigui.iteye.com/blog/368449" title="VIM中的正则表达式">该博客</a>。</p>

<!--more-->


<h3>量词</h3>

<p>VIM中的量词与perl相比</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">VIM    </th>
<th align="center">Perl   </th>
<th align="center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">*      </td>
<td align="center">*      </td>
<td align="center">0个或多个(匹配优先)</td>
</tr>
<tr>
<td></td>
<td align="center">+     </td>
<td align="center">+      </td>
<td align="center">1个或多个(匹配优先)</td>
</tr>
<tr>
<td></td>
<td align="center">\?或\= </td>
<td align="center">?     </td>
<td align="center">0个或1个(匹配优先)，\?不能在 ? 命令（逆向查找）中使用</td>
</tr>
<tr>
<td></td>
<td align="center">{n,m} </td>
<td align="center">{n,m}  </td>
<td align="center">n个到m个(匹配优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{n,}  </td>
<td align="center">{n,}   </td>
<td align="center">最少n个(匹配优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{,m}  </td>
<td align="center">{,m}   </td>
<td align="center">最多m个(匹配优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{n}   </td>
<td align="center">{n}    </td>
<td align="center">恰好n个</td>
</tr>
<tr>
<td></td>
<td align="center">{-n,m}</td>
<td align="center">{n,m}? </td>
<td align="center">n个到m个(忽略优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{-}   </td>
<td align="center">*?     </td>
<td align="center">0个或多个(忽略优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{-1,} </td>
<td align="center">+?     </td>
<td align="center">1个或多个(忽略优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{-,1} </td>
<td align="center">??     </td>
<td align="center">0个或1个(忽略优先)</td>
</tr>
</tbody>
</table>


<h3>环视和固化分组</h3>

<p>这个内容之前没有接触过，只是简单的摘抄下来，后面再进行研究了。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">vim        </th>
<th align="center">Perl   </th>
<th align="center">意义           </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">\@=        </td>
<td align="center">(?=    </td>
<td align="center">顺序环视</td>
</tr>
<tr>
<td></td>
<td align="center">\@!        </td>
<td align="center">(?!    </td>
<td align="center">顺序否定环视</td>
</tr>
<tr>
<td></td>
<td align="center">\@&lt;=       </td>
<td align="center">(?&lt;=   </td>
<td align="center">逆序环视</td>
</tr>
<tr>
<td></td>
<td align="center">\@&lt;!       </td>
<td align="center">(?&lt;!   </td>
<td align="center">逆序否定环视</td>
</tr>
<tr>
<td></td>
<td align="center">\@>        </td>
<td align="center">(?>    </td>
<td align="center">固化分组</td>
</tr>
<tr>
<td></td>
<td align="center">\%(atom)  </td>
<td align="center">(?:    </td>
<td align="center">非捕获型括号</td>
</tr>
</tbody>
</table>


<p>和perl稍有不同的是，vim中的环视和固化分组的模式的位置与perl不同。例如，查找紧跟在 foo 之后的 bar，perl将模式写在环视的括号内，而vim将模式写在环视的元字符之前。
Perl的写法</p>

<blockquote><p>/(?&lt;=foo)bar/
vim的写法
/(foo)\@&lt;=bar</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一个操作系统的实现笔记]]></title>
    <link href="http://xiongbupt.github.com/blog/2012/06/05/os_impletion/"/>
    <updated>2012-06-05T00:00:00+08:00</updated>
    <id>http://xiongbupt.github.com/blog/2012/06/05/os_impletion</id>
    <content type="html"><![CDATA[<p>下面的主要介绍的是Arch下面，对<a href="http://book.douban.com/subject/3735649/" title="一个操作系统的实现">Orange'S一个操作系统的实现</a>，这本书的笔记。</p>

<h1>Arch下工具安装</h1>

<p>文章介绍的汇编器为nasm，在arch下安装相当简单</p>

<blockquote><p>pacman -S nasm</p></blockquote>

<!--more-->


<p>上面这条命令即可完成nasm汇编器的安装。对于虚拟机，使用的是bochs，在Arch下如果使用<code>pacman</code>安装的话，没有调试功能，对于后期的调试不方便。但是在Arch的AUR包中，已经有了bochs的调试版本，仅仅需要使用<code>yaourt -S bochs-with-debugger</code>即可将具有调试功能的bochs虚拟机安装上。</p>

<p>在完成上述操作后，该书介绍的基本工具便已经完备了，接下来便是对bochs进行配置了。</p>

<h1>bochs配置</h1>

<p>bochs的示例配置文件位于<code>/usr/share/doc/bochs/bochsrc-sample.txt</code>，将该配置文件拷贝出来，位于自己工作目录下，并重新命名为bochsrc。这样在每次启动bochs时，便没有必要使用<code>-f</code>来指定使用的配置文件名。</p>

<p>按照书中的推荐配置，bochsrc-sample.txt文件很大，上面有很多不需要的配置选项，按照书中的指示，将bochsrc文件中配置精简为如下所示：</p>

<p>{% codeblock lang:bash %}
megs:   32
floppya: 1_44=a.img, status=inserted
romimage: file=/usr/share/bochs/BIOS-bochs-latest
vgaromimage: file=/usr/share/bochs/VGABIOS-lgpl-latest
boot: floppy
log: bochsout.txt
mouse: enabled=0
keyboard_mapping: enabled=1, map=/usr/share/bochs/keymaps/x11-pc-us.map
{% endcodeblock %}</p>

<h1>汇编文件编译及制作启动软盘</h1>

<p>按照书中第一章节中的介绍，将启动软盘的代码敲入，然后使用nasm编译，使用bximage生成一个虚拟的软盘，接着使用dd工具将对应的编译生成的文件拷贝到相应的软盘工具中。接下来的工作按照书中介绍的内容继续即可。</p>

<h2>附录：汇编代码</h2>

<p>{% codeblock lang:nasm %}</p>

<pre><code>org     07c00h
mov     ax, cs
mov     ds, ax
mov     es, ax
call    DispStr
jmp     $       ;jump to this line, be a dead loop
</code></pre>

<p>DispStr:</p>

<pre><code>mov     ax, BootMessage
mov     bp, ax
mov     cx, 16      ;the length of string
mov     ax, 01301h  ;make the font on the screen
mov     bx, 000ch
mov     dl, 0
int     10h
ret
</code></pre>

<p>BootMessage:        db      "Hello, Os world!"
times   510-($-$$)  db  0
dw      0xaa55
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
