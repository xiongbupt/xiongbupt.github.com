<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Regex | Keep Learning]]></title>
  <link href="http://xiongbupt.github.com/tags/regex/atom.xml" rel="self"/>
  <link href="http://xiongbupt.github.com/"/>
  <updated>2012-06-07T05:58:54+08:00</updated>
  <id>http://xiongbupt.github.com/</id>
  <author>
    <name><![CDATA[Xiongbupt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VIM正则表达式学习]]></title>
    <link href="http://xiongbupt.github.com/blog/2012/06/05/vim_regex_learning/"/>
    <updated>2012-06-05T00:00:00+08:00</updated>
    <id>http://xiongbupt.github.com/blog/2012/06/05/vim_regex_learning</id>
    <content type="html"><![CDATA[<h1>VIM正则表达式</h1>

<p>之前粗略的看了正则表达式的一些内容，但是在VIM中一直用的很少，刚才无意间看到了使用VIM对词进行大小写转换，中间出现了一些正则表达式的内容，从网上找了些内容，觉得可以留下来做个笔记，供以后自己参考。<br/>
文章的主要内容参考<a href="http://qianjigui.iteye.com/blog/368449" title="VIM中的正则表达式">该博客</a>。</p>

<h2>量词</h2>

<p>VIM中的量词与perl相比</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">VIM    </th>
<th align="center">Perl   </th>
<th align="center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">*      </td>
<td align="center">*      </td>
<td align="center">0个或多个(匹配优先)</td>
</tr>
<tr>
<td></td>
<td align="center">+     </td>
<td align="center">+      </td>
<td align="center">1个或多个(匹配优先)</td>
</tr>
<tr>
<td></td>
<td align="center">\?或\= </td>
<td align="center">?     </td>
<td align="center">0个或1个(匹配优先)，\?不能在 ? 命令（逆向查找）中使用</td>
</tr>
<tr>
<td></td>
<td align="center">{n,m} </td>
<td align="center">{n,m}  </td>
<td align="center">n个到m个(匹配优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{n,}  </td>
<td align="center">{n,}   </td>
<td align="center">最少n个(匹配优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{,m}  </td>
<td align="center">{,m}   </td>
<td align="center">最多m个(匹配优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{n}   </td>
<td align="center">{n}    </td>
<td align="center">恰好n个</td>
</tr>
<tr>
<td></td>
<td align="center">{-n,m}</td>
<td align="center">{n,m}? </td>
<td align="center">n个到m个(忽略优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{-}   </td>
<td align="center">*?     </td>
<td align="center">0个或多个(忽略优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{-1,} </td>
<td align="center">+?     </td>
<td align="center">1个或多个(忽略优先)</td>
</tr>
<tr>
<td></td>
<td align="center">{-,1} </td>
<td align="center">??     </td>
<td align="center">0个或1个(忽略优先)</td>
</tr>
</tbody>
</table>


<h2>环视和固化分组</h2>

<p>这个内容之前没有接触过，只是简单的摘抄下来，后面再进行研究了。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">vim        </th>
<th align="center">Perl   </th>
<th align="center">意义           </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">\@=        </td>
<td align="center">(?=    </td>
<td align="center">顺序环视</td>
</tr>
<tr>
<td></td>
<td align="center">\@!        </td>
<td align="center">(?!    </td>
<td align="center">顺序否定环视</td>
</tr>
<tr>
<td></td>
<td align="center">\@&lt;=       </td>
<td align="center">(?&lt;=   </td>
<td align="center">逆序环视</td>
</tr>
<tr>
<td></td>
<td align="center">\@&lt;!       </td>
<td align="center">(?&lt;!   </td>
<td align="center">逆序否定环视</td>
</tr>
<tr>
<td></td>
<td align="center">\@>        </td>
<td align="center">(?>    </td>
<td align="center">固化分组</td>
</tr>
<tr>
<td></td>
<td align="center">\%(atom)  </td>
<td align="center">(?:    </td>
<td align="center">非捕获型括号</td>
</tr>
</tbody>
</table>


<p>和perl稍有不同的是，vim中的环视和固化分组的模式的位置与perl不同。例如，查找紧跟在 foo 之后的 bar，perl将模式写在环视的括号内，而vim将模式写在环视的元字符之前。</p>

<p>Perl的写法</p>

<blockquote><p>/(?&lt;=foo)bar/</p></blockquote>

<p>vim的写法</p>

<blockquote><p>/(foo)\@&lt;=bar</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VIM使用正则表达式改变大小写]]></title>
    <link href="http://xiongbupt.github.com/blog/2012/06/05/vim_regex_case/"/>
    <updated>2012-06-05T00:00:00+08:00</updated>
    <id>http://xiongbupt.github.com/blog/2012/06/05/vim_regex_case</id>
    <content type="html"><![CDATA[<h1>VIM使用正则表达式改变字符大小写</h1>

<p>转载自<a href="http://vim.wikia.com/wiki/Changing_case_with_regular_expressions" title="VIM中使用正则表达式">vim_wiki</a><br/>
在VIM中使用正则表达式来改变单词的大小写是已经很简单的事情。<br/>
只需要简单的将\U或者\L放在想要更改的回溯引用的前面，将\E放置在回溯引用的后面，VIM就会将回溯应用中的大小写进行相应的转换。使用\u和\l（这时不需要在最后使用\E）将会仅仅改变回溯引用中的第一个字符。</p>

<pre><code>回溯引用是正则表达式中的一部分，用来表明匹配前面的一个部分。最常用的回溯表达式有&amp;,\1,\2,\3,...,\9。
</code></pre>

<h1>示例</h1>

<ul>
<li>将整篇文档内容全部小写
<div class="highlight"><pre><code class="bash">:%s/.*/<span class="se">\L</span>&amp;amp;/g
</code></pre>
</div>

  &amp;是一个用来表明匹配前面全部的回溯引用的记录符号。</li>
<li>将紧跟着&lt;后面的字符全部大写，比如在HTML标签中使用。
<div class="highlight"><pre><code class="bash">:%s/&amp;lt;<span class="o">(</span><span class="se">\w</span>*<span class="o">)</span>/&amp;lt;<span class="se">\U\1</span>/g
</code></pre>
</div>
</li>
</ul>


<h1>注释</h1>

<p>注意使用<code>gu</code>和<code>gU</code>命令加上移动操作也可以实现大小写的转换。<br/>
比如<code>ggguG</code>可以实现将全文全部小写，其中，<code>gg</code>代表到达文章的首部，<code>gu</code>代表将文字转换为小写，<code>G</code>代表到达文章末尾（EOF）。</p>

<p>使用\0作为参考引用，而不是使用每个单独命名，比如（\1，\2等），下面的例子演示了\0的使用。</p>

<blockquote><p>This regex upper cases an explicit set of words to uppercase in a file.</p>

<p><code>:%s/\(select\)\|\(order)\|\(by\)\|\(from\)\|\(where\)/\U\0/g</code></p>

<p>Not rocket science, but otherwise you'd have to do this:</p>

<p><code>:%s/\(select\)\|\(order)\|\(by\)\|\(from\)\|\(where\)/\U\1\U\2\U\3\U\4\U\5/g</code></p>

<p>[edit:  Much easier to just use this, where either 0 or 1 will work:]</p>

<p><code>:%s/\(select\|order\|by\|from\|where\)/\U\1/g</code></p></blockquote>

<p>上面的三个操作均是将一文中的几个关键词转换为大写操作，显然方法2显得很不合适，方法1和方法3要高明许多。</p>

<p>将HTML标签全部大写</p>

<blockquote><p>:%s/&lt;\/\=(\w+)>/\U&amp;/g</p></blockquote>

<p>将HTML标签全部小写</p>

<blockquote><p>:%s/&lt;\/\=(\w+)>/\L&amp;/g</p></blockquote>

<p>上面的例子中的<code>\=</code>可以替换成为<code>\?</code>，两个符号的意思都是匹配0个或者1个。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正则表达式学习]]></title>
    <link href="http://xiongbupt.github.com/blog/2012/05/14/regex-learning/"/>
    <updated>2012-05-14T00:00:00+08:00</updated>
    <id>http://xiongbupt.github.com/blog/2012/05/14/regex-learning</id>
    <content type="html"><![CDATA[<h1>不同程序中的regex的使用</h1>

<h3>grep</h3>

<table>
<thead>
<tr>
<th></th>
<th align="center">表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">-E</td>
<td align="center">扩展正则表达式  </td>
</tr>
<tr>
<td></td>
<td align="center">-G</td>
<td align="center">基本正则表达式  </td>
</tr>
<tr>
<td></td>
<td align="center">-P</td>
<td align="center">perl基本表达式  </td>
</tr>
<tr>
<td></td>
<td align="center">-o</td>
<td align="center">仅仅输出匹配结果  </td>
</tr>
<tr>
<td></td>
<td align="center">-v</td>
<td align="center">进行求非操作  </td>
</tr>
<tr>
<td></td>
<td align="center">-c</td>
<td align="center">计算匹配的总数  </td>
</tr>
</tbody>
</table>


<h3>perl</h3>

<table>
<thead>
<tr>
<th></th>
<th align="center">表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">m/pattern/</td>
<td align="center">搜索  </td>
</tr>
<tr>
<td></td>
<td align="center">s/pattern/pattern/</td>
<td align="center">替换  </td>
</tr>
<tr>
<td></td>
<td align="center">qr/pattern/</td>
<td align="center">返回一个regex对象供以后使用  </td>
</tr>
<tr>
<td></td>
<td align="center">split()</td>
<td align="center">把一个字符串拆分成子字符串  </td>
</tr>
<tr>
<td></td>
<td align="center">\i</td>
<td align="center">不区分大小写  </td>
</tr>
<tr>
<td></td>
<td align="center">\g</td>
<td align="center">全局搜索  </td>
</tr>
<tr>
<td></td>
<td align="center">$'</td>
<td align="center">匹配前面的所有东西  </td>
</tr>
<tr>
<td></td>
<td align="center">$`</td>
<td align="center">匹配之后的所有东西  </td>
</tr>
<tr>
<td></td>
<td align="center">$&amp;</td>
<td align="center">整个匹配的字符串  </td>
</tr>
</tbody>
</table>


<h2>匹配纯字符串</h2>

<table>
<thead>
<tr>
<th></th>
<th align="center">表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">\</td>
<td align="center">用来对字符进行转义  </td>
</tr>
<tr>
<td></td>
<td align="center">.</td>
<td align="center">可以用来表示任何字符  </td>
</tr>
</tbody>
</table>


<h2>匹配一组字符</h2>

<p><code>[]</code>用来表示字符集合，出现在它们之间的字符可以使用。字符区间的关系。<br/>
字符区间可以在<code>[]</code>中使用-来实现。<br/>
注意：<br/>
<code>-</code>只有在[]中使用时才有特殊的含义，在其他环境中使用时，不需要使用\进行转义。<br/>
在字符区间中取非使用<code>^</code>元字符。<br/>
注意：<br/>
<code>^</code>的效果作用于给定字符集合里的所哟字符和字符区间，而不仅仅是紧跟在<code>^</code>后的那一个字符或字符区间。</p>

<h2>使用元字符</h2>

<p>对元字符转义需要用到\字符，这个字符对任何元字符都具有转义作用。<br/>
配对的元字符不用作元字符时必须被转义。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">正则表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">[\b]</td>
<td align="center">backtrace  </td>
</tr>
<tr>
<td></td>
<td align="center">\f</td>
<td align="center">换页符  </td>
</tr>
<tr>
<td></td>
<td align="center">\n</td>
<td align="center">换行符  </td>
</tr>
<tr>
<td></td>
<td align="center">\r</td>
<td align="center">回车符  </td>
</tr>
<tr>
<td></td>
<td align="center">\t</td>
<td align="center">制表符(Tab)  </td>
</tr>
<tr>
<td></td>
<td align="center">\v</td>
<td align="center">垂直制表符  </td>
</tr>
</tbody>
</table>


<h2>匹配数字</h2>

<table>
<thead>
<tr>
<th></th>
<th align="center">正则表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">\d</td>
<td align="center">任何一个数字字符，即[0-9]  </td>
</tr>
<tr>
<td></td>
<td align="center">\D</td>
<td align="center">任何一个非数字字符，即[<code>^</code>0-9]  </td>
</tr>
</tbody>
</table>


<h2>匹配字母和数字（包括_)</h2>

<table>
<thead>
<tr>
<th></th>
<th align="center">正则表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">\w</td>
<td align="center">[0-9a-zA-Z_]  </td>
</tr>
<tr>
<td></td>
<td align="center">\W</td>
<td align="center">[<code>^</code>0-9a-zA-Z_]  </td>
</tr>
</tbody>
</table>


<h2>匹配空白</h2>

<table>
<thead>
<tr>
<th></th>
<th align="center">正则表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">\s</td>
<td align="center">[\f\n\t\r\v ]  </td>
</tr>
<tr>
<td></td>
<td align="center">\S</td>
<td align="center">[<code>^</code>\f\n\t\r\v ]  </td>
</tr>
</tbody>
</table>


<p>注意\b，即backtrace没有包含在\s中，因此也就灭有包含在\S中。</p>

<h2>posix字符类</h2>

<table>
<thead>
<tr>
<th></th>
<th align="center">正则表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">[:alnum:]</td>
<td align="center">任何一个字母或数字[a-zA-Z0-9]  </td>
</tr>
<tr>
<td></td>
<td align="center">[:alpha:]</td>
<td align="center">任何一个字母[a-zA-Z]  </td>
</tr>
<tr>
<td></td>
<td align="center">[:blank:]</td>
<td align="center">空格或制表符[\t ]  </td>
</tr>
<tr>
<td></td>
<td align="center">[:cntrl:]</td>
<td align="center">ASCII控制字符(ASCII 0~31, 127)  </td>
</tr>
<tr>
<td></td>
<td align="center">[:digit:]</td>
<td align="center">[0-9]  </td>
</tr>
<tr>
<td></td>
<td align="center">[:graph:]</td>
<td align="center">[:print:]不包括空格  </td>
</tr>
<tr>
<td></td>
<td align="center">[:lower:]</td>
<td align="center">[a-z]  </td>
</tr>
<tr>
<td></td>
<td align="center">[:punct:]</td>
<td align="center">既不属于[:alnum:]，也不属于[:cntrl:]的字符  </td>
</tr>
<tr>
<td></td>
<td align="center">[:space:]</td>
<td align="center">[\f\t\n\r\v ]  </td>
</tr>
<tr>
<td></td>
<td align="center">[:upper:]</td>
<td align="center">[A-Z]  </td>
</tr>
<tr>
<td></td>
<td align="center">[:xdigit:]</td>
<td align="center">[a-fA-F0-9]  </td>
</tr>
</tbody>
</table>


<h2>重复匹配</h2>

<ul>
<li>+出现1次及以上，不包括0次。（是一个元字符，需要使用\进行转义）<br/>
在[]中出现的类似+，.这样的元字符可以不被转义，可以正常使用，但是转义了也没有坏处。</li>
<li>*出现0次及以上，包括0次。（是一个元字符，需要使用\进行转义）</li>
<li>?出现0次或者1次。（是一个元字符，需要使用\进行转义）</li>
<li>{} 出现的次数，用来精确匹配。可以是一个确定的数字，也可以是一个区间。<br/>
  如a{6} 出现6次a
  a{3,5} 至少3次a，最多5次a<br/>
  a{3,}  至少出现3次a，上限没有限制
<strong>注意：</strong>
在匹最好使用\/来进行匹配，防止不必要的麻烦。</li>
</ul>


<p>+,*,{n,}都是贪婪型匹配，每次都尽可能的匹配更长的字符。若想使用这些的懒惰型匹配，在这些后面添加一个?即可。</p>

<table>
<thead>
<tr>
<th></th>
<th align="center">贪婪型</th>
<th align="center">懒惰型</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">*</td>
<td align="center">*?</td>
</tr>
<tr>
<td></td>
<td align="center">+</td>
<td align="center">+?</td>
</tr>
<tr>
<td></td>
<td align="center">{n,}</td>
<td align="center">{n,}?</td>
</tr>
</tbody>
</table>


<h2>位置匹配</h2>

<table>
<thead>
<tr>
<th></th>
<th align="center">正则表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">\b</td>
<td align="center">单词边界（用于一个\w与一个\W之间的匹配)|</td>
</tr>
<tr>
<td></td>
<td align="center">\B</td>
<td align="center">非单词边界</td>
</tr>
<tr>
<td></td>
<td align="center">^</td>
<td align="center">字符串开头</td>
</tr>
<tr>
<td></td>
<td align="center">$</td>
<td align="center">字符串结尾</td>
</tr>
</tbody>
</table>


<h1>使用子表达式</h1>

<p><code>()</code>是元字符，使用它们时需要使用转义，用于将一个子表达式合并在一起组成一个完整的部分。<br/>
<code>|</code>或者<code>,</code>是一个元字符，使用的时候需要使用转义。</p>

<h1>回溯引用</h1>

<p>指的是模式的后半部分引用在前半部分中定义的子表达式，可以把回溯表达式想象成变量。
\1 代表前面模式里的第一个表达式。（需要用括号括起来）</p>

<h2>大小写字母转换</h2>

<table>
<thead>
<tr>
<th></th>
<th align="center">正则表达式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center">\E</td>
<td align="left">结束\L或\U转换</td>
</tr>
<tr>
<td></td>
<td align="center">\l</td>
<td align="left">下一个小写</td>
</tr>
<tr>
<td></td>
<td align="center">\L</td>
<td align="left">\L和\E之间的全部小写</td>
</tr>
<tr>
<td></td>
<td align="center">\u</td>
<td align="left">下一个大写</td>
</tr>
<tr>
<td></td>
<td align="center">\U</td>
<td align="left">\U和\E之间的全部大写</td>
</tr>
</tbody>
</table>


<h1>前后查找</h1>

<h2>向前查找</h2>

<p>向前查找模式其实就是一个以<code>?=</code>开头的子表达式，需要匹配的文本跟在=的后面。找到=后面的即可，不消费它，即不把它包括在内。</p>

<p>例子：</p>

<blockquote><p>.+(?=:)</p></blockquote>

<p><strong>提示：</strong><br/>
任何一个子表达式都可以转换为一个向前查找表达式，只要给它加上一个?=前缀即可。</p>

<h2>向后查找</h2>

<blockquote><p><code>?&lt;=</code><br/>
例子：
(?&lt;=\$)</p>

<pre><code>寻找$符号但是不消费它
</code></pre>

<p><strong>警告：</strong>向前查找模式的长度是可变的，它们可以包含<code>.</code>和<code>+</code>之类的元字符，长度很灵活。而向后查找模式只能是固定长度。</p>

<h2>负向前查找</h2>

<p>?!</p>

<h2>负向后查找</h2>

<p>?&lt;!</p></blockquote>

<h1>嵌入式条件</h1>

<p>Regex中的条件用<code>?</code>来定义</p>

<h2>回溯引用中的条件</h2>

<blockquote><p>?(backreferrenc)true-regex)<br/>
?(backreferrenc)true-regex|false-regex)</p>

<h2>前后查找条件</h2></blockquote>
]]></content>
  </entry>
  
</feed>
